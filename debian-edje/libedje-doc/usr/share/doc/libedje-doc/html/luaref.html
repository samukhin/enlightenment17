<html>
<head>
    <title>Edje Lua scripting</title>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <meta name="author" content="Andres Blanc" >
    <link rel="icon" href="img/favicon.png" type="image/x-icon">
    <link rel="shortcut icon" href="img/favicon.png" type="image/x-icon">
    <link rel="icon" href="img/favicon.png" type="image/ico">
    <link rel="shortcut icon" href="img/favicon.png" type="image/ico">
    <link rel="stylesheet" type="text/css" href="e.css">
    <link rel="stylesheet" type="text/css" href="edoxy.css">
</head>
<body>
<div id="container">
<div id="header">
<div class="layout">
    <h1><span>Enlightenment</span></h1>
    <h2><span>Beauty at your fingertips</span></h2>
    <table cellspacing="0" cellpadding="0" width="100%"><tr>
      <td id="header_logo">
        <a href="http://www.enlightenment.org"></a>
      </td>
      <td id="header_menu">
        <table cellspacing="0" cellpadding="0" align="right"><tr>
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=home">Home</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=news">News</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=about">About</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=download">Download</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=support">Support</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=contribute">Contribute</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=contact">Contact</a></td> 
          <td class="nav_passive"><a class="nav_passive" href="http://trac.enlightenment.org/e">Tracker</a></td>
          <td class="nav_passive"><a class="nav_passive" href="http://www.enlightenment.org/p.php?p=docs">Docs</a></td> 
        </tr></table>          
      </td>
      <td id="header_last"></td>
    </tr></table>
    <div class="doxytitle">
        Edje Documentation <small>at Tue Nov 5 2013</small>
    </div>
    <div class="menu-container">
        <div class="submenu">
            <ul class="current">
                <li><a href="files.html">Files</a></li>
                <li><a href="Edje__Edit_8h.html">Edje Edit API</a></li>
                <li><a href="Examples.html">Examples</a></li>
                <li><a href="luaref.html">LUA scripting</a></li>
                <li><a href="Edje_8h.html">Edje API</a></li>
                <li><a href="edcref.html">EDC Reference</a></li>
                <li><a href="pages.html">Releted Pages</a></li>
                <li class="current"><a  href="index.html">Main Page</a></li>
            </ul>
        </div>
    </div>
    <div class="clear"></div>
</div>
</div>
<div id="content">
<div class="layout">
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Edje Lua scripting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
What is Edje?</h1>
<p>Lua is intended for script-only objects at this point (with embryo left for augmenting standard programs). Since script-only objects effectively define objects entirely via Lua script (resize handling, event handling etc. etc.) this places many more demands on them, and thus a more powerful language is in order. Lua is that language.</p>
<p>To get you started, here's an example that uses most of this lua API: <a class="el" href="lua_script_8edc-example.html">lua_script.edc</a></p>
<p>Most of these lua functions are wrappers around various evas, ecore, and edje C functions. Refer to their documentation for more in depth details and up to date documentation. A lot of this documentation is simple copied from the C functions it wraps.</p>
<h1><a class="anchor" id="args"></a>
Lua function argument and return syntax</h1>
<p>Some of the lua functions can accept a table as well as separate arguments. Some of them return tables.</p>
<h1><a class="anchor" id="classes"></a>
Lua classes</h1>
<h2><a class="anchor" id="edje"></a>
Edje class.</h2>
<p>The lua edje class includes functions for dealing with the lua script only group as an edje object, basic functions, and functions to create other objects.</p>
<p>In the following, "edje" is the actual global table used to access these edje functions.</p>
<h3><a class="anchor" id="edje_echo"></a>
edje:echo(text)</h3>
<p>Make lua a bit shelly. Prints a string to the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to print.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="edje_date"></a>
edje:date()</h3>
<p>Retrieves the current time and date.</p>
<p>Wraps gettimeofday(), as passed through localtime().</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer year: Year.</li>
<li>integer month: Month of the year.</li>
<li>integer day: Day of the month.</li>
<li>integer yearday: Day of the year.</li>
<li>integer weekday: Day of the week.</li>
<li>integer hour: Hour of the day (24 hour format).</li>
<li>integer min: Minute of the hour.</li>
<li>number sec: Seconds as a number.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="edje_looptime"></a>
edje:looptime()</h3>
<p>Retrieves the time at which the last loop stopped waiting for timeouts or events.</p>
<p>This gets the time that the main loop ceased waiting for timouts and/or events to come in or for signals or any other interrupt source. This should be considered a reference point for all time based activity that should calculate its timepoint from the return of edje:looptime(). Use this UNLESS you absolutely must get the current actual timepoint - then use edje:seconds(). Note that this time is meant to be used as relative to other times obtained on this run.</p>
<p>Wraps ecore_loop_time_get().</p>
<dl class="section return"><dt>Returns</dt><dd>A number of seconds.</dd></dl>
<h3><a class="anchor" id="edje_seconds"></a>
edje:seconds()</h3>
<p>Retrieves the current system time as a floating point value in seconds.</p>
<p>This uses a monotonic clock and thus never goes back in time while machine is live (even if user changes time or timezone changes, however it may be reset whenever the machine is restarted).</p>
<p>Wraps ecore_time_get().</p>
<dl class="section return"><dt>Returns</dt><dd>A number of seconds.</dd></dl>
<h3><a class="anchor" id="edje_version"></a>
edje:version()</h3>
<p>Retrieves the current edje version number.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer major: The edje version major number.</li>
<li>integer minor: The edje version minor number.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.2.0</dd></dl>
<h3><a class="anchor" id="edje_geom"></a>
edje:geom()</h3>
<p>Retrieves the position and size of the edje object that this lua group is in.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: The edjes X position.</li>
<li>integer y: The edjes Y position.</li>
<li>integer w: The edjes width.</li>
<li>integer h: The edjes height.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="edje_pos"></a>
edje:pos()</h3>
<p>Retrieves the position of the edje object that this lua group is in.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: The edjes X position.</li>
<li>integer y: The edjes Y position.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="edje_size"></a>
edje:size()</h3>
<p>Retrieves the size of the edje object that this lua group is in.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer w: The edjes width.</li>
<li>integer h: The edjes height.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="edje_emit"></a>
edje:emit(signal, source)</h3>
<p>Emit a signal.</p>
<p>Wraps <a class="el" href="Edje_8h.html#a700d424448139fa85a09906b67dbd62c" title="Send/emit an Edje signal to a given Edje object.">edje_object_signal_emit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>The signal string to send. </td></tr>
    <tr><td class="paramname">source</td><td>The source string of the signal.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: The source string will have a name and a colon prepended to in when it is delivered to things that are not this edje, like C and other edje groups. If this edje is a top level edje, then it will be the name of the group (I think). If this edje is swallowed into some other part, then it will be the name of the part:</p>
<p>group_name:source</p>
<p>FIXME: I actually have no idea what happens if it's swallowed into another lua edje group.</p>
<h3><a class="anchor" id="edje_message_send"></a>
edje:messagesend(id, type, ...)</h3>
<p>Send a message to this edje, and all it's child objects.</p>
<p>Wraps <a class="el" href="Edje_8h.html#aad9c0f29f9a52baef0d34119e4583e8e" title="Send an (Edje) message to a given Edje object.">edje_object_message_send()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>An identification integer for the message. </td></tr>
    <tr><td class="paramname">type</td><td>The type of message to send. </td></tr>
    <tr><td class="paramname">...</td><td>Zero or more things to send as part of the message, depending on the type.</td></tr>
  </table>
  </dd>
</dl>
<p>The type can be one of:</p><ul>
<li>none: No msg.</li>
<li>sig: The msg is two strings (signal, source), sent as a signal.</li>
<li>str: The msg is a C string.</li>
<li>int: The message is a C integer.</li>
<li>float: The message is a C float.</li>
<li>strset: The message is an array of C strings.</li>
<li>intset: The message is an array of C integers.</li>
<li>floatset: The message is an array of C floats.</li>
<li>strint: The message is a C stnring and a C integer.</li>
<li>strfloat: The message is a C string and a C float.</li>
<li>strintset: The message is a C string and an array of C integers.</li>
<li>strfloatset: The message is a G string and an array of C floats.</li>
</ul>
<p>For the array types, the lua caller passes a table.</p>
<h3><a class="anchor" id="edje_animator"></a>
edje:animator(func)</h3>
<p>This function adds an animator and returns its handle on success and NULL on failure. The function func will be called every frame tick. Note that setting the frame tick is not available as a lua function, so has to be done from C. The default tick is 1/30 second.</p>
<p>When the animator func is called, it must return a value of either true or false. If it returns true it will be called again at the next tick, or if it returns false it will be deleted automatically making any references/handles for it invalid.</p>
<p>Wraps ecore_animator_add().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when the animator triggers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an ecore animator.</dd></dl>
<h3><a class="anchor" id="edje_timer"></a>
edje:timer(tick, func)</h3>
<p>This function adds a timer and returns its handle on success and NULL on failure. The function func will be called every tick seconds.</p>
<p>When the timer func is called, it must return a value of either true or false. If it returns true, it will be called again at the next tick, or if it returns false it will be deleted automatically making any references/handles for it invalid.</p>
<p>Wraps ecore_timer_add().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>How often, in seconds, to call the function. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call when the timer triggers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an ecore timer.</dd></dl>
<h3><a class="anchor" id="edje_transition"></a>
edje:transition(div, func)</h3>
<p>Just like edje:animator(), except that the callback function gets called with an argument. The argument is the amount of time since the transition was created, divided by the div parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>A number to divide the time since creation by. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call when the transition triggers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is a transition (ecore animator, plus other info).</dd></dl>
<h3><a class="anchor" id="edje_colour_class"></a>
edje:color_class(class, r, g, b, a)</h3>
<p>Gets, (and optionally sets) the colours for a color class.</p>
<p>Wraps <a class="el" href="Edje_8h.html#a92f450d4d64970ad6114ac2533d1aad3" title="Sets the object color class.">edje_object_color_class_set()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class</td><td>A color class name. </td></tr>
    <tr><td class="paramname">r</td><td>The new red value. </td></tr>
    <tr><td class="paramname">g</td><td>The new green value. </td></tr>
    <tr><td class="paramname">b</td><td>The new blue value. </td></tr>
    <tr><td class="paramname">a</td><td>The new alpha value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the r, g, b, and a arguments are optional, without them this function just queries the current values. The r, g, b, and a arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer r: The red value.</li>
<li>integer g: The green value.</li>
<li>integer b: The blue value.</li>
<li>integer a: The alpha value.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_text_class"></a>
edje:text_class(class, font, size)</h3>
<p>Gets, (and optionally sets) the details for a text class.</p>
<p>Wraps <a class="el" href="Edje_8h.html#a6874f2fcdd21655ebd49e5eb6dab7dfb" title="Sets Edje text class.">edje_object_text_class_set()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class</td><td>A text class name. </td></tr>
    <tr><td class="paramname">font</td><td>The new font name. </td></tr>
    <tr><td class="paramname">size</td><td>The new font size.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the font and size arguments are optional, without them this function just queries the current values. The font and size arguments can be separate values, or named fields in a table. The font name can refer to a font in the edje file, or an external font.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>string font: The font name.</li>
<li>integer size: The font size.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_edje"></a>
edje:edje()</h3>
<p>Create an edje object, and add it to the edje.</p>
<p>Wraps <a class="el" href="Edje_8h.html#a8cb00e5256fd50487f0669bc3bf9b8e0" title="Instantiate a new Edje object.">edje_object_add()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an edje object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_image"></a>
edje:image()</h3>
<p>Create an evas image, and add it to the edje.</p>
<p>Wraps evas_object_image_add().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas image.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_line"></a>
edje:line()</h3>
<p>Create an evas line, and add it to the edje.</p>
<p>Wraps evas_object_line_add().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas line.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_map"></a>
edje:map()</h3>
<p>Create an evas map.</p>
<p>Wraps evas_map_new().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas map.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_polygon"></a>
edje:polygon()</h3>
<p>Create an evas polygon, and add it to the edje.</p>
<p>Wraps evas_object_polygon_add().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas polygon.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_rect"></a>
edje:rect()</h3>
<p>Create an evas rectangle, and add it to the edje.</p>
<p>Wraps evas_object_rectangle_add().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas rectangle.</dd></dl>
<h3><a class="anchor" id="edje_text"></a>
edje:text()</h3>
<p>Create an evas text object, and add it to the edje.</p>
<p>Wraps evas_object_text_add().</p>
<dl class="section return"><dt>Returns</dt><dd>A userdata that is an evas text object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas"></a>
Evas class.</h2>
<p>The lua evas class includes functions for dealing with evas objects. The evas objects must have been previously created by lua using one of the lua ezas object creation functions from the lua edje class.</p>
<p>In the following, "evas_object" is a place holder for any lua variable that holds a reference to an evas object.</p>
<h3><a class="anchor" id="evas_hide"></a>
evas_object:hide()</h3>
<p>Hides the object.</p>
<p>Wraps evas_object_hide().</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing the current visibility.</dd></dl>
<h3><a class="anchor" id="evas_show"></a>
evas_object:show()</h3>
<p>Shows the object.</p>
<p>Wraps evas_object_show().</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing the current visibility.</dd></dl>
<h3><a class="anchor" id="evas_visible"></a>
evas_object:visible(visibility)</h3>
<p>Gets (and optionally sets) this objects visibility.</p>
<p>Wraps evas_object_hide() or evas_object_show().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visibility</td><td>The new visibility you want to change it to.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing the current visibility.</dd></dl>
<h3><a class="anchor" id="evas_above"></a>
evas_object:above()</h3>
<p>Figure out what, if anything, is above us.</p>
<p>Wraps evas_object_above_get().</p>
<p>Note that it may not return any value.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object above this one.</dd></dl>
<h3><a class="anchor" id="evas_below"></a>
evas_object:below()</h3>
<p>Figure out what, if anything, is below us.</p>
<p>Wraps evas_object_below_get().</p>
<p>Note that it may not return any value.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object below this one.</dd></dl>
<h3><a class="anchor" id="evas_bottom"></a>
evas_object:bottom()</h3>
<p>Figure out what, if anything, is waaaay below us.</p>
<p>Note that it may not return any value.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object at the bottom.</dd></dl>
<h3><a class="anchor" id="evas_lower"></a>
evas_object:lower()</h3>
<p>Lower this object to the bottom.</p>
<p>Wraps evas_object_lower().</p>
<h3><a class="anchor" id="evas_raise"></a>
evas_object:raise()</h3>
<p>Raise this object to the top.</p>
<p>Wraps evas_object_raise().</p>
<h3><a class="anchor" id="evas_top"></a>
evas_object:top()</h3>
<p>Figure out what, if anything, is waaaay above us.</p>
<p>Note that it may not return any value.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object at the top.</dd></dl>
<h3><a class="anchor" id="evas_geom"></a>
evas_object:geom(x, y, w, h)</h3>
<p>Gets (and optionally sets) this objects geometry.</p>
<p>Wraps evas_object_move() and evas_object_resize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The new X coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>The new Y coordinate. </td></tr>
    <tr><td class="paramname">w</td><td>The new width. </td></tr>
    <tr><td class="paramname">h</td><td>The new height.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: X coordinate.</li>
<li>integer x: Y coordinate.</li>
<li>integer w: Width.</li>
<li>integer w: Height.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="evas_move"></a>
evas_object:move(x, y)</h3>
<p>Gets (and optionally sets) this objects position.</p>
<p>Wraps evas_object_move().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The new X coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>The new Y coordinate.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: X coordinate.</li>
<li>integer x: Y coordinate.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="evas_pos"></a>
evas_object:pos(x, y)</h3>
<p>An alias for evas_object:move().</p>
<h3><a class="anchor" id="evas_resize"></a>
evas_object:resize(w, h)</h3>
<p>Gets (and optionally sets) this objects size.</p>
<p>Wraps evas_object_resize().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The new width. </td></tr>
    <tr><td class="paramname">h</td><td>The new height.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer w: Width.</li>
<li>integer w: Height.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="evas_size"></a>
evas_object:size()</h3>
<p>An alias for evas_object:resize().</p>
<h3><a class="anchor" id="evas_clip"></a>
evas_object:clip(evas_object2)</h3>
<p>Get (and optionally set) the object that clips this object.</p>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<p>Wraps evas_object_clip_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evas_object2</td><td>A reference to the object to clip this object with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object clipping this object, if any.</dd></dl>
<h3><a class="anchor" id="evas_clipees"></a>
evas_object:clipees()</h3>
<p>Gets the list of objects this objects clips.</p>
<p>Wraps evas_object_clipees_get().</p>
<dl class="section return"><dt>Returns</dt><dd>A table, that holds all the objects this clips, if any, otherwise an empty table.</dd></dl>
<h3><a class="anchor" id="evas_unclip"></a>
evas_object:unclip()</h3>
<p>Remove any clipping on this object.</p>
<p>Wraps evas_object_clip_unset().</p>
<h3><a class="anchor" id="evas_type"></a>
evas_object:type()</h3>
<p>Get the type of this object. See the documentation of the evas_object_type_get() C function for details.</p>
<p>Wraps evas_object_type_get().</p>
<dl class="section return"><dt>Returns</dt><dd>A string with this objects type in it.</dd></dl>
<h3><a class="anchor" id="evas_pass"></a>
evas_object:pass(pass)</h3>
<p>Get (and optionally set) whether this object ignores events, passing them to the next object underneath it.</p>
<p>Wraps evas_object_pass_events_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass</td><td>A boolean saying if this object passes events.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean saying if this object passes events.</dd></dl>
<h3><a class="anchor" id="evas_precise"></a>
evas_object:precise(precise)</h3>
<p>Get (and optionally set) whether to use precise (usually expensive) point collision detection for this object.</p>
<p>Wraps evas_object_precise_is_inside_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precise</td><td>A boolean saying if this object is precisely detected.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean saying if this object is precisely detected.</dd></dl>
<h3><a class="anchor" id="evas_repeat"></a>
evas_object:repeat(repeat)</h3>
<p>Get (and optionally set) whether this object repeats events.</p>
<p>Wraps evas_object_repeat_events_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>A boolean saying if this object repeats events to lower objects.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean saying if this object repeats events.</dd></dl>
<h3><a class="anchor" id="evas_colour"></a>
evas_object:color(r, g, b, a)</h3>
<p>Gets (and optionally sets) this objects colour.</p>
<p>Wraps evas_object_color_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The new red value. </td></tr>
    <tr><td class="paramname">g</td><td>The new green value. </td></tr>
    <tr><td class="paramname">b</td><td>The new blue value. </td></tr>
    <tr><td class="paramname">a</td><td>The new alpha value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer r: The red value.</li>
<li>integer g: The green value.</li>
<li>integer b: The blue value.</li>
<li>integer a: The alpha value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="evas_map"></a>
evas_object:map(map)</h3>
<p>Attach a map to this object.</p>
<p>Wraps evas_object_map_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map to attach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="evas_map_enable"></a>
evas_object:map_enable(enable)</h3>
<p>Enable or disable the map attached to this object.</p>
<p>Wraps evas_object_map_enable_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A booleon that controls if the attached map is enabled or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean reflecting the map enabled status of this object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="ecore_animator"></a>
Ecore animator class.</h2>
<p>The lua ecore animator class includes functions for dealing with ecore animator objects. The ecore animator objects must have been previously created by lua using the lua edje object creation function edje:animator() or edje:transition().</p>
<p>In the following, "animator_object" is a place holder for any lua variable that holds a reference to an ecore animator object.</p>
<h2><a class="anchor" id="ecore_timer"></a>
Ecore timer class.</h2>
<p>The lua ecore timer class includes functions for dealing with ecore timer objects. The ecore timer objects must have been previously created by lua using the lua edje object creation function edje:timer().</p>
<p>In the following, "timer_object" is a place holder for any lua variable that holds a reference to an ecore timer object.</p>
<h2><a class="anchor" id="evas_edje"></a>
Evas edje class.</h2>
<p>The lua evas edje class includes functions for dealing with evas edje objects. The evas edje objects must have been previously created by lua using the lua edje object creation function edje:edje().</p>
<p>In the following, "edje_object" is a place holder for any lua variable that holds a reference to an evas edje object. NOT the edje class specified earlier though.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="edje_file"></a>
edje_object:file(file, group)</h3>
<p>Load an edje group into this edje object.</p>
<p>Wraps <a class="el" href="Edje_8h.html#ab375d28c2726ccc32165b66b64abfc0a" title="Sets the EDJ file (and group within it) to load an Edje object&#39;s contents from.">edje_object_file_set()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An edje file name (ignored, sandboxed to the file this lua script is in). </td></tr>
    <tr><td class="paramname">group</td><td>The group within the edje file to be loaded.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table. The file argument is optional, and ignored anyway.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>string file: The name of the edje file this edje's group is loaded from.</li>
<li>string group: The name of the group this edje is loaded from.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas_image"></a>
Evas image class.</h2>
<p>The lua evas image class includes functions for dealing with evas image objects. The evas image objects must have been previously created by lua using the lua image object creation function edje:image().</p>
<p>In the following, "image_object" is a place holder for any lua variable that holds a reference to an evas image object.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="image_fill"></a>
image_object:fill(x, y, w, h)</h3>
<p>Gets (and optionally sets) how to fill this image's drawing rectangle given the (real) image bound to it.</p>
<p>Wraps evas_object_image_fill_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramname">y</td><td>The y coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramname">w</td><td>The width the bound image will be displayed at. </td></tr>
    <tr><td class="paramname">h</td><td>The height the bound image will be displayed at.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: The x coordinate (from the top left corner of the bound image) to start drawing from.</li>
<li>integer y: The y coordinate (from the top left corner of the bound image) to start drawing from.</li>
<li>integer w: The width the bound image will be displayed at.</li>
<li>integer h: The height the bound image will be displayed at.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="image_filled"></a>
image_object:filled(filled)</h3>
<p>Get (and optionally set) whether this image fills the object.</p>
<p>Wraps evas_object_image_filled_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filled</td><td>A boolean saying if this image fills the object.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean saying if this image fills the object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="image_image"></a>
image_object:image(file, key)</h3>
<p>Load an image into this edje object.</p>
<p>Wraps evas_object_image_file_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An edje file name (ignored, sandboxed to the file this lua script is in). </td></tr>
    <tr><td class="paramname">group</td><td>The name of an image.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table. The file argument is optional, and ignored anyway.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>string file: The name of the edje file the image is loaded from.</li>
<li>string key: The name of the image within the edje file.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas_line"></a>
Evas line class.</h2>
<p>The lua evas line class includes functions for dealing with evas line objects. The evas line objects must have been previously created by lua using the lua line object creation function edje:line().</p>
<p>In the following, "line_object" is a place holder for any lua variable that holds a reference to an evas line object.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="line_xy"></a>
line_object:xy(x1, y1, x2, y2)</h3>
<p>Sets the end points of this line.</p>
<p>Wraps evas_object_line_xy_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The X coordinate of the first line end. </td></tr>
    <tr><td class="paramname">y1</td><td>The Y coordinate of the first line end. </td></tr>
    <tr><td class="paramname">x2</td><td>The X coordinate of the other line end. </td></tr>
    <tr><td class="paramname">y2</td><td>The Y coordinate of the other line end.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x1: The X coordinate of the first line end.</li>
<li>integer y1: The Y coordinate of the first line end.</li>
<li>integer x2: The X coordinate of the other line end.</li>
<li>integer y2: The Y coordinate of the other line end.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas_object_map"></a>
Evas map class.</h2>
<p>The lua evas map class includes functions for dealing with evas map objects. The evas map objects must have been previously created by lua using the lua map object creation function edje:map(). The evas map system is complex, rather than repeat the copious documentation here, please refer to the evas map documentation. It has pictures and everything. B-)</p>
<p>In the following, "map_object" is a place holder for any lua variable that holds a reference to an evas map object.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_alpha"></a>
map_object:alpha(alpha)</h3>
<p>Get (and optionally set) the maps alpha mode.</p>
<p>Wraps evas_map_alpha_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>The alpha mode.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean reflecting the alpha mode.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_clockwise"></a>
map_object:clockwise()</h3>
<p>Get the maps clockwise state.</p>
<p>Wraps evas_map_util_clockwise_get().</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean reflecting if the map is clockwise or not.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_colour"></a>
map_object:colour(index, r, g, b, a)</h3>
<p>Gets or sets colour information for the map. There are two variations, with or without the index. With the index parameter it gets (and optionally sets) the colour of the point the index refers to, without it sets the colour for the entire map.</p>
<p>Wraps evas_map_point_color_set() or evas_map_util_points_color_set()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Which point to change the colour of. </td></tr>
    <tr><td class="paramname">r</td><td>The new red value. </td></tr>
    <tr><td class="paramname">g</td><td>The new green value. </td></tr>
    <tr><td class="paramname">b</td><td>The new blue value. </td></tr>
    <tr><td class="paramname">a</td><td>The new alpha value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The colour arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer r: The red value.</li>
<li>integer g: The green value.</li>
<li>integer b: The blue value.</li>
<li>integer a: The alpha value.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_coord"></a>
map_object:coord(index, x, y, z)</h3>
<p>Gets (and optionally sets) the 3D coordinates of a point on the map.</p>
<p>Wraps evas_map_point_coord_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x coordinate of the point. </td></tr>
    <tr><td class="paramname">y</td><td>The y coordinate of the point. </td></tr>
    <tr><td class="paramname">z</td><td>The z coordinate of the point.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the arguments are optional, without them this function just queries the current values. The coordinate arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>integer x: The x coordinate of the point.</li>
<li>integer y: The y coordinate of the point.</li>
<li>integer z: The z coordinate of the point.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_lighting"></a>
map_object:lighting(x, y, z, r, g, b, ar, ag, ab)</h3>
<p>Set the 3D lights for the map. The three triplets can be tables.</p>
<p>Wraps evas_map_util_3d_lighting().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x coordinate of the light point. </td></tr>
    <tr><td class="paramname">y</td><td>The y coordinate of the light point. </td></tr>
    <tr><td class="paramname">z</td><td>The z coordinate of the light point. </td></tr>
    <tr><td class="paramname">r</td><td>The new red value of the light point. </td></tr>
    <tr><td class="paramname">g</td><td>The new green value of the light point. </td></tr>
    <tr><td class="paramname">b</td><td>The new blue value of the light point. </td></tr>
    <tr><td class="paramname">ar</td><td>The new red value of the ambient light. </td></tr>
    <tr><td class="paramname">ag</td><td>The new green value of the ambient light. </td></tr>
    <tr><td class="paramname">ab</td><td>The new blue value of the ambient light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_perspective"></a>
map_object:perspective(x, y, z, f)</h3>
<p>Apply a perspective transform to the map.</p>
<p>Wraps evas_map_util_3d_perspective().</p>
<p>The arguments can be separate values, or named fields in a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The perspective distance X coordinate </td></tr>
    <tr><td class="paramname">y</td><td>The perspective distance Y coordinate </td></tr>
    <tr><td class="paramname">z</td><td>The "0" z plane value </td></tr>
    <tr><td class="paramname">f</td><td>The focal distance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_populate"></a>
map_object:populate(...)</h3>
<p>Populate the points in a map, in one of three different methods.</p>
<p>1) Wraps evas_map_util_points_populate_from_object().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An evas object to copy points from.</td></tr>
  </table>
  </dd>
</dl>
<p>2) Wraps evas_map_util_paints_populate_from_object_full().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>An evas object to copy points from. </td></tr>
    <tr><td class="paramname">z</td><td>Common Z coordinate hint for all four points.</td></tr>
  </table>
  </dd>
</dl>
<p>3) Wraps evas_map_util_points_populate_from_geometry().</p>
<p>The first four arguments can be separate values, or named fields in a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Point X coordinate </td></tr>
    <tr><td class="paramname">y</td><td>Point Y coordinate </td></tr>
    <tr><td class="paramname">w</td><td>Width to use to calculate second and third points. </td></tr>
    <tr><td class="paramname">h</td><td>Height to use to calculate third and fourth points. </td></tr>
    <tr><td class="paramname">z</td><td>Common Z coordinate hint for all four points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_rotate"></a>
map_object:rotate(degrees, x, y)</h3>
<p>Rotate the maps coordinates in 2D.</p>
<p>Wraps evas_map_util_rotate().</p>
<p>The coordinates can be separate values, or named fields in a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>Amount of degrees from 0.0 to 360.0 to rotate. </td></tr>
    <tr><td class="paramname">x</td><td>Rotation's centre horizontal position. </td></tr>
    <tr><td class="paramname">y</td><td>Rotation's centre vertical position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_rotate3d"></a>
map_object:rotate3d(dx, dy, dz, x, y, z)</h3>
<p>Rotate the maps coordinates in 3D.</p>
<p>Wraps evas_map_util_3d_rotate().</p>
<p>The coordinates can be separate values, or named fields in a table. The same with the rotation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Amount of degrees from 0.0 to 360.0 to rotate around X axis. </td></tr>
    <tr><td class="paramname">dy</td><td>Amount of degrees from 0.0 to 360.0 to rotate around Y axis. </td></tr>
    <tr><td class="paramname">dz</td><td>Amount of degrees from 0.0 to 360.0 to rotate around Z axis. </td></tr>
    <tr><td class="paramname">x</td><td>Rotation's centre horizontal position. </td></tr>
    <tr><td class="paramname">y</td><td>Rotation's centre vertical position. </td></tr>
    <tr><td class="paramname">z</td><td>Rotation's centre vertical position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_smooth"></a>
map_object:smooth(smooth)</h3>
<p>Get (and optionally set) the maps smooth mode.</p>
<p>Wraps evas_map_smooth_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>The smooth mode.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean reflecting the smooth mode.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_uv"></a>
map_object:uv(index, u, v)</h3>
<p>Gets (and optionally sets) the texture U and V texture coordinates for this map.</p>
<p>Wraps evas_map_point_image_uv_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the point to change. Must be smaller than map size. </td></tr>
    <tr><td class="paramname">u</td><td>The X coordinate within the image/texture source. </td></tr>
    <tr><td class="paramname">v</td><td>The Y coordinate within the image/texture source.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the U,V arguments are optional, without them this function just queries the current values. The coordinate arguments can be separate values, or named fields in a table.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>number u: The X coordinate within the image/texture source.</li>
<li>number v: The Y coordinate within the image/texture source.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="map_zoom"></a>
map_object:zoom(x, y, x, y)</h3>
<p>Apply a zoom to the map.</p>
<p>Wraps evas_map_util_zoom().</p>
<p>The arguments can be two separate values, or named fields in a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The horizontal zoom amount. </td></tr>
    <tr><td class="paramname">y</td><td>The vertical zoom amount. </td></tr>
    <tr><td class="paramname">x</td><td>The X coordinate of the centre of the zoom. </td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the centre of the zoom.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas_polygon"></a>
Evas polygon class.</h2>
<p>The lua evas polygon class includes functions for dealing with evas polygon objects. The evas polygon objects must have been previously created by lua using the lua polygon object creation function edje:polygon().</p>
<p>In the following, "polygon_object" is a place holder for any lua variable that holds a reference to an evas polygon object.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="polygon_clear"></a>
polygon_object:clear()</h3>
<p>Clears all points from the polygon.</p>
<p>Wraps evas_object_polygon_points_clear(),</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="polygon_point"></a>
polygon_object:point(x, y)</h3>
<p>Adds a point to this polygon.</p>
<p>Wraps evas_object_polygon_point_add().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The X coordinate of the point. </td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h2><a class="anchor" id="evas_text"></a>
Evas text class.</h2>
<p>The lua evas text class includes functions for dealing with evas text objects. The evas text objects must have been previously created by lua using the lua text object creation function edje:text().</p>
<p>In the following, "text_object" is a place holder for any lua variable that holds a reference to an evas text object.</p>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="text_font"></a>
text_object:font(font, size)</h3>
<p>Gets, (and optionally sets) the font for this text object.</p>
<p>Wraps evas_object_text_font_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">font</td><td>The new font name. </td></tr>
    <tr><td class="paramname">size</td><td>The new font size.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the font and size arguments are optional, without them this function just queries the current values. The font and size arguments can be separate values, or named fields in a table. The font name can refer to a font in the edje file, or an external font.</p>
<dl class="section return"><dt>Returns</dt><dd>A table with these fields:<ul>
<li>string font: The font name.</li>
<li>integer size: The font size.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h3><a class="anchor" id="text_text"></a>
text_object:text(text)</h3>
<p>Get (and optionally set) the actual text for this text object.</p>
<p>Wraps evas_object_text_text_set().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The text to set for this text object.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the argument is optional, without it this function just queries the current value.</p>
<dl class="section return"><dt>Returns</dt><dd>A string of the text on this text object.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1.0</dd></dl>
<h1><a class="anchor" id="callbacks"></a>
Lua callbacks</h1>
<p>These are lua functions that are called by the lua edje system when certain events occur. If the functions don't exist in the lua group, they don't get called.</p>
<h2><a class="anchor" id="edje_shutdown"></a>
Edje shutdown() callback.</h2>
<p>If a function called "shutdown" exists in a lua edje group, then it is called when that edje gets deleted.</p>
<h2><a class="anchor" id="edje_show"></a>
Edje show() callback.</h2>
<p>If a function called "show" exists in a lua edje group, then it is called when that edje gets shown.</p>
<h2><a class="anchor" id="edje_hide"></a>
Edje hide() callback.</h2>
<p>If a function called "hide" exists in a lua edje group, then it is called when that edje gets hidden.</p>
<h2><a class="anchor" id="edje_move"></a>
Edje move(x, y) callback.</h2>
<p>If a function called "move" exists in a lua edje group, then it is called when that edje gets moved, with the new position passed to it.</p>
<h2><a class="anchor" id="edje_resize"></a>
Edje resize(w, h) callback.</h2>
<p>If a function called "resize" exists in a lua edje group, then it is called when that edje gets resized, with the new size passed to it.</p>
<h2><a class="anchor" id="edje_message"></a>
Edje message(id, type, ...) callback.</h2>
<p>If a function called "message" exists in a lua edje group, then it is called when that edje gets gets a message sent to it, with the message details passed to it. See edje:messagesend() for details of what each type means. The arrays are passed as a table.</p>
<h2><a class="anchor" id="edje_signal"></a>
Edje signal(signal, source) callback.</h2>
<p>If a function called "signal" exists in a lua edje group, then it is called when ever a signal arrives, with the signal details passed to it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
 
 <div id="push"></div>
 </div> <!-- #content -->
  </div> <!-- .layout -->
 </div> <!-- #container -->
  <div id="footer">
    <table><tr>
      <td class="copyright">Copyright &copy;2013 Enlightenment</td>
      <td class="generated">Docs generated Tue Nov 5 2013 19:12:59</td>
    </tr></table>
  </div>
</body>
</html>
